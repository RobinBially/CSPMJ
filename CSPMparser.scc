/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * A Parser for CSP in JAVA                           		  *
 * CSPMJ V0.1.1606XX										  *
 *															  *
 * robin.bially@hhu.de		                                  *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

//Fehlt: Wildcard pattern, double_pattern links, diverse interne Funktionen
Package CSPMparser;
Helpers

	all = [0 .. 0xFFFF];
	dangle_l = 0x00AB;
	dangle_r = 0x00BB;
	char = [all- ['''+'"']];
	digits = ['0' .. '9'];
	first_digit = [digits - '0'];
	highc = ['A' .. 'Z'];
	lowc = ['a' .. 'z'];
	letter = (highc | lowc | '_');
	letter_digits = (letter|digits);	
    tab = 9;
    cr = 13;
    lf = 10;
	not_cr_lf = [all - [cr + lf]];	
	eol = cr lf | cr | lf;
	blank = (' '|tab);
	white = (' '|tab|cr|lf)*;
	
/*	Triangle substitutions:
	\u00AB = «	seq opening
	\u00BB = »	seq closing
	\u00A3 = £	greater
	\u20AC = €  smaller
*/
	seq_open	=	0x00AB;
	seq_close	=	0x00BB;
	greater 	=	0x00A3;
	less		=	0x20AC;

Tokens
//***************************************************************************************	
//Predefined functions and constants
	stop 			= 'STOP';
	skip 			= 'SKIP';
	chaos 			= 'CHAOS';
	div				= 'DIV';
	wait 			= 'WAIT';
	run				= 'RUN';
	member 			= 'member';
	empty 			= 'empty';
	null 			= 'null';
	bool_const		= 'Bool';
	bool_func		= 'bool';
	diff 			= 'diff';
	card 			= 'card';
	events 			= 'Events';
	head 			= 'head';
	tail 			= 'tail';
	concat 			= 'concat';
	union1 			= 'union';
	union2 			= 'Union';
	inter1			= 'inter';
	inter2 			= 'Inter';
	set1 			= 'set';
	set2 			= 'Set';
	seq1 			= 'seq';
	seq2			= 'Seq';
	length 			= 'length';
	proc 			= 'Proc';
	char_const		= 'Char'; 
	int_const 		= 'Int';
	error			= 'error';
	show			= 'show';
	true_const		= 'True';
	false_const		= 'False';
	ltl				= 'LTL';
	ctl				= 'CTL';
//***************************************************************************************
//CSPM command words	
	if 				= 'if';
	then 			= white 'then' white;
	else 			= white 'else' white;
	let 			= 'let';
	within 			= 'within' white;
	d_type 			= 'datatype';
	s_type 			= 'subtype';
	n_type 			= 'nametype';
	channel 		= 'channel';
	transparent 	= 'transparent';
	external		= 'external';
	assert 			= 'assert';
	include 		= 'include';
	print 			= 'print';
	dl_free 		= 'deadlock free';
	div_free 		= 'divergence free';
	det 			= 'deterministic';
	live_free 		= 'livelock free';
	has_trace 		= 'has trace';
	timed 			= 'Timed';
	mod_defs		= 'module';	
	exports			= 'exports';
	endmodule		= 'endmodule';
	and 			= 'and';
	or 				= 'or';
	not 			= 'not';

//---------------------------------------------------------------------------------------
	comma 			= ',' white;
	apo 			= ''';
	quote			= '"';
	dotdot 			= white '..' white;
	ddot 			= white ':' white;
	eq 				= '=' white;
	at 				= '@' white;
	hash 			= '#' white;
	b_slash 		= white '\' white;
	q_mark 			= '?';
	excl_mark 		= '!';
	dollar 			= '$';
	dpipe 			= white '||' white;
	pipe_equals		= white '|=' white; 
	pipe 			= white '|' white;
	doubleat 		= white '@@' white;
	i_leaving 		= white '|||' white;
	i_choice  		= white '|~|' white;
	e_choice  		= white '[]' white;
	interrupt 		= white '/\' white;
	timeout			= white '[>' white;
//-------------------------------------	
	par_l 			= '(' white;
	par_r 			=  white ')';
	empty_map 		= '(| |)';
	lge 			= white '<=' white | white '>=' white;
	seq_open		= seq_open white;
	seq_close 		= white seq_close;
	greater 		= white greater;
	less	 		= less white;		
	tria_l			= '<' white;
	tria_r			= white '>';
	sync_par_l		= '[+' white;	
	sync_par_r		= white '+]';
	sync_int_l 		= '/+' white;
	sync_int_r		= white '+\';
	dbracket_l 		= white '[[' white;
	dbracket_r 		= white ']]';
	dp_bracket 		= white ':[' white;
	bracket_pipe_l	= white '[|' white;
	bracket_pipe_r	= white '|]' white;
	bracket_l 		= white '[' white;
	bracket_r 		= white ']';
	brace_l 		= '{' white;
	brace_r 		= white '}';
//-------------------------------------	
	guard 			= white '&' white;
	dot 			= white '.' white;
	semicolon 		= white ';' white;
	prefix			= white '->' white;
	arrow_l 		= '<-';
	cat 			= white '^' white;
	d_arr 			= '<->';	
	equi 			= '<=>';
	imp_r 			= '=>';
	imp_l 			= '<=';
	equal			= white '==' white | white '!=' white;
	tra_mod 		= white '[T=' white;
	fail_mod  		= white '[F=' white;
	fail_div 		= white '[FD=' white;
	t_mod 			= white '[T]' white;
	f_mod		    = white '[F]' white; 
	f_div		    = white '[FD]' white;
	mul_div_mod 	=  white '*' white | white '/' white | white '%' white;
	plus 			=  white '+' white;
	minus		    =  '-';
//---------------------------------------------------------------------------------------	
	/*Strings*/ 
	number 			= '0' | first_digit digits*;
	identifier 		= letter letter_digits* '''*;
	nl				= eol;
	string			= '"' char* '"';
	char			= ''' char ''';
	blank			= blank*;

	
Ignored Tokens
	blank;

Productions
defs 		 =	 {many_lines} def_nl+ def_no_nl?
				|{one_line} def_no_nl;
def_nl 		 =	 def? nl;
def_no_nl 	 =	 def;
def			 =	 {expression} expression 
				|{include_file} include_file
				|{d_type_s_type} types
				|{n_type} ntype
				|{channel} chan
				|{assertion} assertion
				|{print} print_exp
				|{timed_section} time
				|{module} module
				|{trans} transparent id
				|{ext} external id;		
//---------------------------------------------------------------------------------------
types			= {dtype} d_type typedef |{stype} s_type typedef;
typedef 		= id eq clause typedef_rek*;
clause  		= [clause_name]:id dotted?;
dotted  		= dot type_exp;
typedef_rek 	= pipe clause;

ntype 			= n_type id eq type_exp;	  
//---------------------------------------------------------------------------------------
/*Creation of Channels*/
chan 		= channel id chan_rek?;
chan_rek 	= {rek} comma id chan_rek? | {end} ddot type_exp;
//---------------------------------------------------------------------------------------			
type_exp 		=  	 {dotted} type_exp dot type_exp1
					|{par} type_exp1;
type_exp1 		= 	 {par} par_l type_exp type_exps* par_r 
					|{set_type} type_exp2;
type_exp2 		=  	 {set} set
					|{set_name} func_id;
type_exps  		= 	 comma type_exp;

//---------------------------------------------------------------------------------------
//Create a function or an identifier

//  ACHTUNG: Aufteilung in tuple+ und !tuple muss erfolgen: tuple* führt dazu, dass
//  keine Unterscheidung bei channel c erfolgen kann, z.B.:
//  f::(<a>)->bool und f(<3>):: bool, dann wäre eine Funktion mit Argumenten als
//  channel-Name erlaubt. Analyse des Namens an Ort und Stelle ist zu aufwändig.	
	 
func_id	=    {id} identifier tuple+
			|{ltl} ltl tuple+
			|{ctl} ctl tuple+
			|{stop} stop tuple+
			|{skip} skip tuple+
			|{chaos} chaos tuple+		
			|{div} div tuple+
			|{wait} wait tuple+
			|{run} run tuple+			
			|{member} member tuple+
			|{empty} empty tuple+
			|{null} null tuple+	
			|{bool_const} bool_const tuple+
			|{bool_func} bool_func tuple+
			|{union1} union1 tuple+			
			|{inter1} inter1 tuple+
			|{diff} diff tuple+
			|{union2} union2 tuple+		
			|{inter2} inter2 tuple+ 
			|{card} card tuple+
			|{events} events tuple+	
			|{set2} set2 tuple+
			|{head} head tuple+
			|{tail} tail tuple+			
			|{concat} concat tuple+ 
			|{set1} set1 tuple+
			|{seq1} seq1 tuple+			
			|{length} length tuple+
			|{proc} proc tuple+
			|{char_const} char_const tuple+
			|{error} error tuple+		
			|{show} show tuple+
			|{int_const} int_const tuple+
			|{true_const} true_const tuple+
			|{false_const} false_const tuple+
			|{seq2} seq2 tuple+
			|{identifier} id;
					
id 		=	 {id} identifier |{ltl} ltl |{ctl} ctl |{stop} stop |{skip} skip 
			|{chaos} chaos |{div} div |{wait} wait |{run} run |{member} member 
			|{empty} empty |{null} null |{bool_const} bool_const |{bool_func} bool_func
			|{union1} union1 |{inter1} inter1 |{diff} diff |{union2} union2 		
			|{inter2} inter2 |{card} card |{events} events |{set2} set2 
			|{head} head |{tail} tail |{concat} concat |{set1} set1 
			|{seq1} seq1 |{length} length |{proc} proc |{char_const} char_const 
			|{error} error |{show} show |{int_const} int_const
			|{true_const} true_const |{false_const} false_const | {seq2} seq2;
//---------------------------------------------------------------------------------------
/*Creation of Expressions*/	

expression  =	 {new_def} func_id eq proc1
				|{tuple} tuple eq proc1
				|{set} set eq proc1
				|{sequence} sequence eq proc1;
	
proc1 		=  	 {double_pattern} proc1 doubleat proc2 
				|{p2} proc2;
proc2 		=  	 {hide} proc2 b_slash proc3 
				|{p3} proc3;

proc3 		=    {ileave} proc3 i_leaving proc4 
				|{p4} proc4;
proc4 		=  	 {except} proc4 bracket_pipe_l event [r]:pipe tria_r proc5
				|{gen_par} proc4 bracket_pipe_l event bracket_pipe_r proc5
				|{alph_par} proc4 bracket_l [l]:event dpipe [r]:event bracket_r proc5
				|{linked_par} proc4 bracket_l link_comp bracket_r proc5
				|{p5} proc5;				
proc5 		=  	 {int_choice} proc5 i_choice proc6 
				|{p6} proc6;
proc6 		=  	 {ext_choice} proc6 e_choice proc7 
				|{sync_ext} proc6 sync_par_l event sync_par_r proc7
				|{p7} proc7;
proc7 		= 	 {interrupt} proc7 interrupt proc8 
				|{sync_interrupt} proc7 sync_int_l event sync_int_r proc8
				|{p8} proc8;
proc8 		= 	 {sliding_choice} proc8 timeout proc9 
				|{p9} proc9;
proc9 		= 	 {seq_comp} proc9 semicolon proc10 
				|{p10} proc10; 
proc10		= 	 {guard_exp} dot_op guard proc10
				|{prefix} event prefix proc10
				|{lambda_term} b_slash inner_tuple at proc10 
				|{let_within} let defs within proc10
				|{if_else} if bool_exp then proc1 else proc10
				|{rep} rep proc10
				|{p11} proc11;				
proc11 		=	 {renaming} proc11 dbracket_l rename_comp dbracket_r
				|{e_renaming} proc11 dbracket_l dbracket_r
				|{event} event;
			
event 		= 	 {event} dot_op field1* field2*;				
field1 		= 	 {nondet_rest} dollar dot_rest;
field2		=	 {input_rest} q_mark dot_rest
				|{output} excl_mark dot_op;
dot_rest 	= 	 {dot_rest} bool_exp dot dot_rest 
				|{rest} restricted
				|{bool_exp} bool_exp;
restricted  =	  bool_exp ddot atom;
dot_op 		=	 {dot} dot_op dot bool_exp
				|{ss} bool_exp;				
				
bool_exp 	= 	 {or} bool_exp or bool_exp2 
				|{bool_exp2} bool_exp2;
bool_exp2 	= 	 {and} bool_exp2 and bool_exp3 
				|{bool_exp3} bool_exp3; 		
bool_exp3 	= 	 {not} not bool_exp3 
				|{bool_exp4} bool_exp4;
bool_exp4 	= 	 {equal} bool_exp4 equal val_exp
				|{ordering_lge} bool_exp4 lge val_exp
				|{ordering_less} bool_exp4 less val_exp 
				|{ordering_greater} bool_exp4 greater val_exp 
				|{val_exp} val_exp;				
val_exp 	= 	 {addition} val_exp plus val_exp1 
				|{subtraction} val_exp minus val_exp1
				|{val_exp1} val_exp1; 			  			
val_exp1 	= 	 {multiplication} val_exp1 mul_div_mod val_exp2 
				|{val_exp2} val_exp2;
val_exp2 	= 	 {un_minus} minus val_exp2 
				|{sequence0} sequence0;		
sequence0	= 	 {len} hash sequence0 | {sequence1} sequence1;
sequence1 	=	 {cat} sequence1 cat atom | {atom} atom;
atom 		= 	 {num} number
				|{sequence} sequence
				|{string} string
				|{char} char
				|{set} set
				|{map} map
				|{tuple} [tuple]:tuple [lambda]:tuple?
				|{fid} func_id;
//---------------------------------------------------------------------------------------
/*(e1,e2,...,en) different types possible*/
tuple 	 		=  {tuple} par_l inner_tuple par_r;
inner_tuple 	=  {inner_start} proc1 comma inner_tuple
				  |{inner_end} proc1;
//---------------------------------------------------------------------------------------
link_comp 			= [l]:event d_arr [r]:event link_comp_rek* comp_rek?;
link_comp_rek 		= comma [l]:event d_arr [r]:event;
		
rename_comp			= [l]:event arrow_l [r]:event rename_comp_rek* comp_rek?;
rename_comp_rek 	= comma [l]:event arrow_l [r]:event;

comp_rek			= pipe stmts_set;
		
//---------------------------------------------------------------------------------------					
/*Examples: <>, <v,w>, <1..3>,<4..>,<0..99/x|x<-<11>>*/	
sequence =	 {empty_seq} seq_open seq_close
			|{expl_seq} seq_open inner_sequence seq_close
			|{list_comp} seq_open inner_sequence pipe stmts_seq seq_close
			|{cr_seq} seq_open [l]:val_exp dotdot [r]:val_exp seq_close
			|{ran_comp} seq_open [l]:val_exp dotdot [r]:val_exp pipe stmts_seq seq_close
			|{or_seq} seq_open val_exp dotdot seq_close
			|{inf_compr} seq_open val_exp dotdot pipe stmts_seq seq_close
			|{enum_seq} enum_seq
			|{seq_comp}	seq_comp;
			
stmts_seq 			=  {gs} gen_stmt_seq 
					  |{ps} pred_stmt_seq;
gen_stmt_seq 		=  [l]:val_exp arrow_l [r]:val_exp stmt_rek_seq*;					
stmt_rek_seq 		=  {gs}comma [l]:val_exp arrow_l [r]:val_exp
					  |{ps} comma pred_stmt_seq;
pred_stmt_seq		=  val_exp; 

inner_sequence 			=  inner_sequence_rek;		
inner_sequence_rek		=  {start} proc1 comma inner_sequence_rek
						  |{end} proc1;
					  
enum_seq 	  		=  tria_l [l]:pipe arguments [r]:pipe tria_r;
seq_comp  			=  tria_l [l]:pipe arguments [m]:pipe stmts_set [r]:pipe tria_r;
				 
//---------------------------------------------------------------------------------------				 
/*Examples: {v,w,x,y,z}, {m..n}, {m..},{x*2..64|x<-{8,4}}*/
set = 	{empty_set} brace_l brace_r
		|{set} brace_l arguments brace_r
		|{closed_range} brace_l [l]:val_exp dotdot [r]:val_exp brace_r
		|{open_range} brace_l val_exp dotdot brace_r
		|{set_comprehension} brace_l arguments pipe stmts_set brace_r
		|{ranged_comprehension} brace_l [l]:val_exp dotdot [r]:val_exp pipe stmts_set brace_r
		|{infinite_comprehension} brace_l val_exp dotdot pipe stmts_set brace_r
		|{enum_set} enum_set
		|{set_comp} set_comp;

stmts_set				=    {gs} gen_stmt_set 
							|{ps} pred_stmt_set;
gen_stmt_set 			=    [l]:event arrow_l [r]:proc1 stmt_rek_set*;
stmt_rek_set 			=    {gs}comma [l]:event arrow_l [r]:proc1
						    |{ps} comma pred_stmt_set;
pred_stmt_set			=    bool_exp;
							
				
enum_set   	    =  brace_l [l]:pipe arguments [r]:pipe brace_r;
set_comp		=  brace_l [l]:pipe arguments [m]:pipe stmts_set [r]:pipe brace_r;

//---------------------------------------------------------------------------------------
// e1,e2,...,en    all of type a!
arguments		= arguments_rek;
arguments_rek	=  {arg_start} proc1 comma arguments_rek
				  |{arg_end} proc1;
//---------------------------------------------------------------------------------------
map	 =	  {map} par_l [lp]:pipe[le]:bool_exp imp_r [re]:bool_exp [rp]:pipe par_r
		  |{emptymap} empty_map;
//---------------------------------------------------------------------------------------		 	 
//ACHTUNG SET STATEMENTS -> identifier : {}
rep = 			 {ext_choice} e_choice rep_stmts at
				|{int_choice} i_choice rep_stmts at
				|{i_leave} i_leaving rep_stmts at
				|{seq_comp} semicolon rep_stmts at
				|{alp_par} dpipe rep_stmts at bracket_l event bracket_r
				|{sharing} bracket_pipe_l val_exp bracket_pipe_r rep_stmts at
				|{linked_par} bracket_l link_comp bracket_r rep_stmts at
				|{sync_par} sync_par_l [l]:event sync_par_r rep_stmts at;
	
	
rep_stmts 			= 	 {rgs} rep_gen_stmt
						|{rps} rep_pred_stmt;
rep_gen_stmt 		= 	 [la]:atom ddot [ra]:atom rep_gen_stmt_rek*;
rep_gen_stmt_rek	= 	 {gs} comma [la]:atom ddot [ra]:atom
						|{ps} comma rep_pred_stmt;
rep_pred_stmt 		= 	 bool_exp;
//---------------------------------------------------------------------------------------	
assertion = 	 {tra_mod} assert [l]:proc1 tra_mod [r]:proc1
				|{fm} assert [l]:proc1 fail_mod [r]:proc1
				|{fd} assert [l]:proc1 fail_div [r]:proc1
				|{ltl} assert proc1 pipe_equals ltl ddot string
				|{ctl} assert proc1 pipe_equals ctl ddot string
				|{dl_free} assertion_dl
				|{div_free} assertion_div
				|{det} assertion_det
				|{live_free} assertion_ll
				|{has_trace} assertion_ht
				|{negated_assertion} not assertion;

			
assertion_dl =  	  {dl_main} assert proc1 dp_bracket dl_free bracket_r
					 |{fm} assert proc1 dp_bracket dl_free f_mod bracket_r
					 |{fd} assert proc1 dp_bracket dl_free f_div bracket_r;
					 
assertion_div =  	 {div_main} assert proc1 dp_bracket div_free bracket_r
					|{fd} assert proc1 dp_bracket div_free f_div bracket_r;
					 
assertion_det = 	 {det_main} assert proc1 dp_bracket det bracket_r
					|{fm} assert proc1 dp_bracket det f_mod bracket_r
					|{fd} assert proc1 dp_bracket det f_div bracket_r;
							
assertion_ll = 		assert proc1 dp_bracket live_free bracket_r;

assertion_ht = 	{trace_main} assert proc1 dp_bracket has_trace bracket_r [r]:ddot val_exp
				|{tra_mod} assert proc1 dp_bracket has_trace t_mod bracket_r [r]:ddot val_exp
				|{fm} assert proc1 dp_bracket has_trace f_mod bracket_r [r]:ddot val_exp
				|{fd} assert proc1 dp_bracket has_trace f_div bracket_r [r]:ddot val_exp;
	
//---------------------------------------------------------------------------------------	
print_exp 	= 	 {pe} print proc1;
//---------------------------------------------------------------------------------------
time =  timed par_l proc1 par_r brace_l defs brace_r;
//---------------------------------------------------------------------------------------
module = mod_defs id [ls]:defs exports [rs]:defs endmodule;
//---------------------------------------------------------------------------------------
/*Include File if path is valid*/
include_file = include string;	
